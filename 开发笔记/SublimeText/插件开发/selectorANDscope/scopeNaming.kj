scope(作用域) naming 
syntax(语法) definitions(定义) and color schemes(主题) in sublime text interact(互动) through the use of scope(作用域) names. scopes(作用域) are dotted(点分的) strings, specified(详细说明) from least-to-most specific(细节). for example(例子), the if keyword(关键字) in php could be specified(详细说明) via(通过) the scope(作用域) name keyword(关键字).control.php. 
sublime text supports(支持) textmate(文本助手) language grammars(语法), and inherited(继承) its default syntaxes(语法) from various(各种各样的) open-source(原始资料) bundles(束). the textmate(文本助手) language grammar(语法) documentation(文档) provided(提供) a base set of scope(作用域) names that have been slowly expanded(扩展) and changed by the community(社区). 
this is a living document(文档) that attempts(试图) to document(文档) best practices(实践) for using scope(作用域) names in syntax(语法) definitions(定义) and color schemes(主题). all of the sublime text default packages strive(努力) to adhere(依附) to these recommendations(推荐规范). 





usage(用法) in syntax(语法) definitions(定义) 
example(例子) syntaxes(语法)
alphabetical(字母顺序的) reference(参考)
usage(用法) in color schemes(主题) 





usage(用法) in syntax(语法) definitions(定义)
the scopes(作用域) documented(记录) below are a recommended(推荐) base set of scope(作用域) names to use when creating a syntax(语法) definition(定义). 
in this documentation(文档), the syntax(语法) name is omitted(删除,忽略) from the end of the dotted(点分的) scope(作用域) name. when writing a syntax(语法), unless otherwise noted(<动>指出), the syntax(语法) name should be the final segment(<名>分段,部分) of a dotted(点分的) name. for example(例子), a control keyword(关键字) in ruby(红宝石) would be keyword(关键字).control.ruby(红宝石), whereas(然而) in python it would be keyword(关键字).control.python. 





example(例子) syntaxes(语法)
it is an on-going(正在进行的) process(过程,进程) to improve(改进,改善) and expand(扩展) upon(在上面) the default syntaxes(语法) that are shipped(航运,上市) with sublime text. as of(截至) early-2019, the following syntaxes(语法) have been recently(最近地) re-worked(再加工), and may be used as a reference(参考): 
css 
python 
go 
html 
php 
c# 





alphabetical(字母顺序的) reference(参考)
the following, top-level, list of scopes(作用域) is sorted(整理,分类) alphabetically(字母顺序地). it is recommended(推荐) to read through the entire list at least once before writing or modifying(修改) a syntax(语法). 
comment(评论,解释). 
constant(<形>恒定的,<名>常量). 
entity(<名>实体,独立存在物). 
invalid(无效的). 
keyword(关键字). 
markup(标记符号). 
meta(元). 
punctuation(标点符号). 
source(原始资料). 
storage(贮藏(空间)). 
string. 
support(支持). 
text. 
variable(变量). 
comment(评论,解释).

single and multi-line(多行的) comments(评论,解释) should use, respectively(分别地,各自地): 
comment(评论,解释).line 
comment(评论,解释).block 

multi-line(多行的) comments(评论,解释) used as documentation(文档), such as javadoc or phpdoc, should use: 
comment(评论,解释).block.documentation(文档) 

symbols(字符) that delineate(描画,解释) a comment(评论,解释), e.g.(例如) // or /*, should additionally(额外地,进一步地) use: 
punctuation(标点符号).definition(定义).comment(评论,解释) 

comments(评论,解释) with special syntax(语法) that denote(预示,表示) a section(部门,章节) of code, should use the following scope(作用域) on the text only. this will cause it to be shown in the symbol(字符) list. 
meta(元).toc-list 
constant(<形>恒定的,<名>常量).

numeric(数字的) literals(字面量), including integers, floats, etc. should use one of: 
constant(<形>恒定的,<名>常量).numeric(数字的) 
constant(<形>恒定的,<名>常量).numeric(数字的).integer 
constant(<形>恒定的,<名>常量).numeric(数字的).integer.binary(二进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).integer.octal(八进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).integer.decimal(十进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).integer.hexadecimal(十六进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).integer.other 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数) 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数).binary(二进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数).octal(八进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数).decimal(十进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数).hexadecimal(十六进制) 
constant(<形>恒定的,<名>常量).numeric(数字的).float(浮点数).other 
constant(<形>恒定的,<名>常量).numeric(数字的).complex(复合的) 
constant(<形>恒定的,<名>常量).numeric(数字的).complex(复合的).real 
constant(<形>恒定的,<名>常量).numeric(数字的).complex(复合的).imaginary(想象的) 

constants(常量) that are built into the language, such as booleans and null values, should use: 
constant(<形>恒定的,<名>常量).language 

character(字符) escapes in strings, e.g.(例如) \n and \x20, should use: 
constant(<形>恒定的,<名>常量).character(字符).escape 

formatting placeholders, such as those used for sprintf(), e.g.(例如) %s, should use: 
constant(<形>恒定的,<名>常量).other.placeholder 

other language-specific(细节) constant(<形>恒定的,<名>常量) values, such as symbols(字符) in ruby(红宝石), should use: 
constant(<形>恒定的,<名>常量).other 
entity(<名>实体,独立存在物).
the entity(<名>实体,独立存在物) scopes(作用域) are generally assigned to the names of data structures, types and other uniquely-identifiable constructs in code and markup(标记符号). the notable exceptions are entity(<名>实体,独立存在物).name.tag and entity(<名>实体,独立存在物).other.attribute-name, which are used in html and xml tags. 
the names of data structures will use one of the following scopes(作用域), or a new sub-scope(作用域) of entity(<名>实体,独立存在物).name – this list is not exhaustive. to provide rich semantic information, use the specific(细节) terminology for a given language construct. 
avoid entity(<名>实体,独立存在物).name.type.class and entity(<名>实体,独立存在物).name.type.struct which unnecessarily nest scope(作用域) labels under type. 
entity(<名>实体,独立存在物).name.class 
entity(<名>实体,独立存在物).name.struct 
entity(<名>实体,独立存在物).name.enum 
entity(<名>实体,独立存在物).name.union 
entity(<名>实体,独立存在物).name.trait 
entity(<名>实体,独立存在物).name.interface 
entity(<名>实体,独立存在物).name.impl 
entity(<名>实体,独立存在物).name.type 
forward-decl variants of the above are used in languages such as c and c++. such scopes(作用域) can be used to exclude identifiers from the symbol(字符) list and indexing. 
entity(<名>实体,独立存在物).name.class.forward-decl 
class, interface and trait names listed as an inherited(继承) class or implemented interface/trait should use: 
entity(<名>实体,独立存在物).other.inherited(继承)-class 
function names receive one of the following scopes(作用域). these are included in the symbol(字符) list and index. 
entity(<名>实体,独立存在物).name.function 
entity(<名>实体,独立存在物).name.function.constructor 
entity(<名>实体,独立存在物).name.function.destructor 
namespaces, packages and modules use the following scope(作用域). there are usually not multiple types of such constructs in a language, so this scope(作用域) should suffice. 
entity(<名>实体,独立存在物).name.namespace 
constants(常量) should use the following scope(作用域) or variable(变量).other.constant(<形>恒定的,<名>常量), depending on the language semantics. this scope(作用域) is often included in the symbol(字符) list and index. 
entity(<名>实体,独立存在物).name.constant(<形>恒定的,<名>常量) 
labels for goto-like constructs should use: 
entity(<名>实体,独立存在物).name.label 
heading names in markup(标记符号) languages, such as markdown and textile, should use: 
entity(<名>实体,独立存在物).name.section(部门,章节) 
html and xml tags should use the following scope(作用域). this is the only entity(<名>实体,独立存在物).name scope(作用域) that is applied to repeated constructs. 
entity(<名>实体,独立存在物).name.tag 
html, css and xml use the following for tag attribute names: 
entity(<名>实体,独立存在物).other.attribute-name 
invalid(无效的).
elements that are illegal in a specific(细节) context should use the following scope(作用域). overuse of this will likely lead to unpleasant highlighting for users as they edit code. 
invalid(无效的).illegal 
deprecated elements should be scoped using the following scope(作用域). this should be very rarely used, as users may be working with older versions of a language. 
invalid(无效的).deprecated 
keyword(关键字).
control keywords examples include if, try, end and while. some syntaxes(语法) prefer to mark if and else with the conditional variant. the import variant is often used in appropriate situations. 
keyword(关键字).control 
keyword(关键字).control.conditional 
keyword(关键字).control.import 
keywords that contain punctuation(标点符号), such as the @ symbol(字符) in css, add the following scope(作用域) to the symbols(字符): 
punctuation(标点符号).definition(定义).keyword(关键字) 
all remaining non-operator keywords fall under the other variant: 
keyword(关键字).other 
operators are typically symbols(字符), so the term keyword(关键字) can seem somewhat contradictory. specific(细节) variants are sometimes referenced based on the type of operator. 
keyword(关键字).operator 
keyword(关键字).operator.assignment 
keyword(关键字).operator.arithmetic 
keyword(关键字).operator.bitwise 
keyword(关键字).operator.logical 
when the operator is a word, such as and, or or not, the following variant is used: 
keyword(关键字).operator.word 
markup(标记符号).
markup(标记符号) scopes(作用域) are used for content, as opposed to code. this includes syntaxes(语法) such as markdown and textile. 
section(部门,章节) headings should use: 
markup(标记符号).heading 
lists should use one of: 
markup(标记符号).list.unnumbered 
markup(标记符号).list.numbered 
basic text styling should use one of: 
markup(标记符号).bold 
markup(标记符号).italic 
markup(标记符号).underline 
inserted and deleted content, such as with diff output, should use: 
markup(标记符号).inserted 
markup(标记符号).deleted 
links should use: 
markup(标记符号).underline.link 
blockquotes and other quote styles should use: 
markup(标记符号).quote 
inline and block literal quoting, often used for code, should use: 
markup(标记符号).raw.inline 
markup(标记符号).raw.block 
other markup(标记符号), including constructs such as footnotes and tables, should use: 
markup(标记符号).other 
meta(元).
meta(元) scopes(作用域) are used to scope(作用域) larger sections of code or markup(标记符号), generally containing multiple, more specific(细节) scopes(作用域). these are not intended to be styled by a color scheme, but used by preferences and plugins. 
the complete contents of data structures should be scoped using one of the following scopes(作用域). similar to entity(<名>实体,独立存在物).name, they should be customized per language to provide rich semantic information. they should include all elements, such as the name, inheritance details and body. 
meta(元).class 
meta(元).struct 
meta(元).enum 
meta(元).union 
meta(元).trait 
meta(元).interface 
meta(元).impl 
meta(元).type 
the entire scope(作用域) of a function should be covered by one of the following scopes(作用域). each variant should be applied to a specific(细节) part, and not stacked. for example(例子), meta(元).function.php meta(元).function.parameters.php should never occur, but instead the scopes(作用域) should alternate between meta(元).function.php then meta(元).function.parameters.php and back to meta(元).function.php. 
meta(元).function 
meta(元).function.parameters 
meta(元).function.return-type 
the entirety of a namespace, module or package should use: 
meta(元).namespace 
preprocessor statements in language such as c should use: 
meta(元).preprocessor 
annotations, attributes and decorator statements that are used to modify the behavior or implementation of a class, method or function should use one of the following meta(元) scopes(作用域) for each component of the annotation. that is to say, there should never be more than one meta(元).annotation* scope(作用域) on the stack at any given time. see variable(变量).annotation for scoping the identifier. 
meta(元).annotation 
meta(元).annotation.identifier 
meta(元).annotation.parameters 
punctuation(标点符号).definition(定义).annotation 
complete identifiers, including namespace names, should use the following scope(作用域). such identifiers are the fully-qualified forms of variable(变量), function and class names. for example(例子), in c++ a path may look like myns::myclass, whereas(然而) in php it would appears such as \myns\myclass. 
meta(元).path 
function names, including the full path, and all parameters should receive the following scope(作用域). the name of the function or method should be variable(变量).function, unless the function is scoped with support(支持).function. 
meta(元).function-call 
sections of code delineated by curly braces should use one the following meta(元) scopes(作用域), based on appropriate semantics. the { and } characters should additionally(额外地,进一步地) use the punctuation(标点符号) scopes(作用域). 
meta(元).block 
punctuation(标点符号).section(部门,章节).block.begin 
punctuation(标点符号).section(部门,章节).block.end 
meta(元).braces 
punctuation(标点符号).section(部门,章节).braces.begin 
punctuation(标点符号).section(部门,章节).braces.end 
sections of code delineated by parentheses should use one the following meta(元) scopes(作用域), based on appropriate semantics. the ( and ) characters should additionally(额外地,进一步地) use the punctuation(标点符号) scopes(作用域). 
meta(元).group 
punctuation(标点符号).section(部门,章节).group.begin 
punctuation(标点符号).section(部门,章节).group.end 
meta(元).parens 
punctuation(标点符号).section(部门,章节).parens.begin 
punctuation(标点符号).section(部门,章节).parens.end 
sections of code delineated by square brackets should use the following scope(作用域). the [ and ] characters should additionally(额外地,进一步地) use the punctuation(标点符号) scopes(作用域). 
meta(元).brackets 
punctuation(标点符号).section(部门,章节).brackets.begin 
punctuation(标点符号).section(部门,章节).brackets.end 
generic data type constructs should use the following scope(作用域). any symbols(字符) that denote(预示,表示) the beginning and end, such as < and >, should additionally(额外地,进一步地) use the punctuation(标点符号) scopes(作用域). 
meta(元).generic 
punctuation(标点符号).definition(定义).generic.begin 
punctuation(标点符号).definition(定义).generic.end 
html and xml tags, including punctuation(标点符号), names and attributes should use the following: 
meta(元).tag 
paragraphs in markup(标记符号) languages use: 
meta(元).paragraph 
punctuation(标点符号).
the following scopes(作用域) are punctuation(标点符号) scopes(作用域) that are not embedded within other scopes(作用域). for instance, the string. section(部门,章节) includes documentation(文档) about scopes(作用域) for string punctuation(标点符号). 
separators such as commas and colons should use: 
punctuation(标点符号).separator 
semicolons or other statement terminators should use: 
punctuation(标点符号).terminator 
line-continuation characters, such as in python and r, should use: 
punctuation(标点符号).separator.continuation 
member access, scope(作用域) resolution, or similar constructs should use the following scope(作用域). for python or javascript this would be .. in php this would be applied to -> and ::. in c++, this would be applied to all three. 
punctuation(标点符号).accessor 
source(原始资料).
a language-specific(细节) variant of the following scope(作用域) is typically applied to the entirety of a source(原始资料) code file: 
source(原始资料) 
storage(贮藏(空间)).
types should use the following scope(作用域). examples include int, bool and char. 
storage(贮藏(空间)).type 
keywords that affect the storage(贮藏(空间)) of a variable(变量), function or data structure should use the following scope(作用域). examples include static, inline, const, public and private. 
storage(贮藏(空间)).modifier 
keywords for functions or methods should use the following scopes(作用域). example(例子) keywords include func, function and def. this includes storage(贮藏(空间)).type for backwards compatibility with older color schemes(主题). 
storage(贮藏(空间)).type.function keyword(关键字).declaration.function 
keywords for classes, structs, interfaces, etc should use the following scopes(作用域) – this list is not exhaustive. example(例子) keywords include class, struct, impl and typedef. this includes storage(贮藏(空间)).type for backwards compatibility with older color schemes(主题). 
storage(贮藏(空间)).type.class keyword(关键字).declaration.class 
storage(贮藏(空间)).type.struct keyword(关键字).declaration.struct 
storage(贮藏(空间)).type.enum keyword(关键字).declaration.enum 
storage(贮藏(空间)).type.union keyword(关键字).declaration.union 
storage(贮藏(空间)).type.trait keyword(关键字).declaration.trait 
storage(贮藏(空间)).type.interface keyword(关键字).declaration.interface 
storage(贮藏(空间)).type.impl keyword(关键字).declaration.impl 
storage(贮藏(空间)).type keyword(关键字).declaration.type 
string.
basic strings use the one of the following scopes(作用域), based on the type of quotes used: 
string.quoted.single 
string.quoted.double 
string.quoted.triple 
strings that used unconventional quotes, such as < and > with c imports, should use: 
string.quoted.other 
the entirety of a string, along with all punctuation(标点符号), prefixes, suffixes and interpolations should use: 
meta(元).string 
punctuation(标点符号) at the beginning and end of strings should use: 
punctuation(标点符号).definition(定义).string.begin 
punctuation(标点符号).definition(定义).string.end 
unquoted strings, such as in shell and batch file, should use: 
string.unquoted 
regular expression literals(字面量) should use: 
string.regexp 
when a string contain interpolated code, such as a variable(变量) or expression, the string.* scope(作用域) should be removed using clear_scopes:, and the following should be added to the entirety of the interpolation, including punctuation(标点符号): 
meta(元).interpolation 
the punctuation(标点符号) for an interpolated expression should be: 
punctuation(标点符号).section(部门,章节).interpolation.begin 
punctuation(标点符号).section(部门,章节).interpolation.end 
between the punctuation(标点符号), the interpolated expression should get: 
source(原始资料).language-suffix.embedded 
support(支持).
elements provided(提供) by a base framework should use one of the following scopes(作用域). examples include cocoa within objective-c, or the browser/node within javascript. 
support(支持).constant(<形>恒定的,<名>常量) 
support(支持).function 
support(支持).module 
while also used for base frameworks, many syntaxes(语法) apply these to scopes(作用域) unrecognized classes and types, effectively scoping all user constructs. 
support(支持).type 
support(支持).class 
text.
programming languages use source(原始资料). as their base scope(作用域), whereas(然而) content uses text.. one of the biggest differences is the fact that many plugins and other dynamic functionality is disabled within text. scopes(作用域). markup(标记符号). scopes(作用域) are typically used within text. 
html should use the following scope(作用域). variants for this scope(作用域) are different than other scopes(作用域), in that the variant is always added after the .html, such as text.html.basic or text.html.markdown. 
text.html 
xml should use: 
text.xml 
variable(变量).
a generic variable(变量) should use the following scope(作用域). some languages use the readwrite variant for contrast with the constant(<形>恒定的,<名>常量) variant discussed below. 
variable(变量).other 
variable(变量).other.readwrite 
symbols(字符) that are part of the variable(变量) name, should additionally(额外地,进一步地) be applied the following scope(作用域). for example(例子), the $ in php and shell. 
punctuation(标点符号).definition(定义).variable(变量) 
immutable variables, often via(通过) a const modifier, should receive the following scope(作用域). depending on the language and semantics, entity(<名>实体,独立存在物).name.constant(<形>恒定的,<名>常量) may be a better choice. 
variable(变量).other.constant(<形>恒定的,<名>常量) 
reserved variable(变量) names that are specified(详细说明) by the language, such as this, self, super, etc. should use: 
variable(变量).language 
parameters to a function or methods should use the following scope(作用域). this may also be used for other parameter-like variables, such as receivers or named return values in go. 
variable(变量).parameter 
fields, properties, members and attributes of a class or other data structure should use: 
variable(变量).other.member 
function and method names should be scoped using the following, but only when they are being invoked. when defined, they should use entity(<名>实体,独立存在物).name.function. 
variable(变量).function 
the final label in an identifier that is part of an annotation should use the following. for the entire identifier, the meta(元).path scope(作用域) should be used. the entire annotation should get meta(元).annotation. 
variable(变量).annotation 
the leading symbol(字符) used to delineate(描画,解释) an annotation should use: 
punctuation(标点符号).definition(定义).annotation 
usage(用法) in color schemes(主题)
in general, when applying colors and styles to scopes(作用域) in a color scheme, the most general form of a selector should be styled first. high-quality syntaxes(语法) utilizing the scopes(作用域) outlined in the previous section(部门,章节) should result is good user experience for end users. 
minimal scope(作用域) coverage
the following is a recommended(推荐) minimal set of scopes(作用域) to highlight. adding extra may result in a slightly improved experience, however being too specific(细节) will result in a color scheme that often only looks good for one or two syntaxes(语法). 
entity(<名>实体,独立存在物).name
entity(<名>实体,独立存在物).other.inherited(继承)-class
entity(<名>实体,独立存在物).name.section(部门,章节)
entity(<名>实体,独立存在物).name.tag
entity(<名>实体,独立存在物).other.attribute-name
variable(变量)
variable(变量).language
variable(变量).parameter
variable(变量).function
constant(<形>恒定的,<名>常量)
constant(<形>恒定的,<名>常量).numeric(数字的)
constant(<形>恒定的,<名>常量).language
constant(<形>恒定的,<名>常量).character(字符).escape
storage(贮藏(空间)).type
storage(贮藏(空间)).modifier
support(支持)
keyword(关键字)
keyword(关键字).control
keyword(关键字).operator
keyword(关键字).declaration
string
comment(评论,解释)
invalid(无效的)
invalid(无效的).deprecated
meta(元). colors
when styling scopes(作用域), resist the urge to directly style meta(元) scopes(作用域). they are primarily intended to provide contextual information for preferences and plugins. 
entity(<名>实体,独立存在物).name. colors
historically, many color schemes(主题) have provided(提供) one color for entity(<名>实体,独立存在物).name.function and entity(<名>实体,独立存在物).name.type, and often a different color for entity(<名>实体,独立存在物).name.tag. this leaves new entity(<名>实体,独立存在物).name.* scopes(作用域) un-highlighted. 
color schemes(主题) should instead specify a color for entity(<名>实体,独立存在物).name that will be applied to classes, types, structs, interfaces and many other data structures. this color can be overridden for the two scopes(作用域) entity(<名>实体,独立存在物).name.tag and entity(<名>实体,独立存在物).name.section(部门,章节), that are used for different types of constructs. 
© sublime hq pty ltd 
woollahra, sydney. 